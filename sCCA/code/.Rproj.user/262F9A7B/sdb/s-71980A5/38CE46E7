{
    "collab_server" : "",
    "contents" : "load_power_net <- function(sample_qa){\n  n_sample <- dim(sample_qa)[1]\n  sample_net<-array(NA, c(264, 264, n_sample))\n  for (i in 1:n_sample){\n    scanid <- sample_qa$scanid[i]\n    netpath<- paste(\"./studies/pnc/n1601_dataFreeze2016/neuroimaging/rest/restNetwork_264PowerPNC/264PowerPNCNetworks/\",scanid,\"_264PowerPNC_network.txt\",sep=\"\")\n    sample_net[,,i] <- as.matrix(read.table(netpath))\n    print(paste(i,\".\",\" copying \",scanid,\"_\",\"Power\",sep=\"\"))\n  }\n  \n  #make feature table of the matrix\n  print(\"making feature table\")\n  net_ft <-t(apply(sample_net,c(3),function(x) x[upper.tri(x, diag = F)]))\n  \n  print(\"making inclusion net mat\")\n  \n  inc_net <- net_ft[,pwr.3k.train.idx]\n}\n\n\nload_reg_power_net <- function(sample_qa){\n  #load net\n  \n  inc_net <- load_power_net(sample_qa)\n  \n\n  \n  # Compile covariates\n  print(\"Compile covariates\")\n  \n  sample_qa$sex <- as.factor(sample_qa$sex)\n  sample_qa$race2 <- as.factor(sample_qa$race2)\n  \n  # Regress\n  \n  print(\"Regress out covariates\")\n  inc_net[which(is.na(inc_net))] <- 0\n  net.rgr <- apply(inc_net, 2, function(x) residuals.glm(glm(x ~ ageAtScan1 + \n                                                               sex + race2 + restRelMeanRMSMotion, data = sample_qa), type = \"response\"))\n}\n\n\n\ncv_score <- function(uhat_tr,vhat_tr,X_ts,Y_ts){\n  score <- CCA(X_ts %*% uhat_tr , Y_ts %*% vhat_tr )\n} \n\nccaDW <- function(X,Y,pen_x,pen_y,rank){\n  mode<-PMA::CCA(x=X, z=Y, typex=c(\"standard\"),typez=c(\"standard\"), penaltyx=pen_x, penaltyz=pen_y, K=rank, niter=100, trace=FALSE)\n}\n\nccaDWpermorder <- function(X,Y,pen_x,pen_y,rank,Y_org){\n  perm.mode<-PMA::CCA(x=X, z=Y, typex=c(\"standard\"),typez=c(\"standard\"), penaltyx=pen_x, penaltyz=pen_y, K=rank*2, niter=20, trace=FALSE)\n  org.mode <-PMA::CCA(x=X, z=Y_org, typex=c(\"standard\"),typez=c(\"standard\"), penaltyx=pen_x, penaltyz=pen_y, K=rank, niter=20, trace=FALSE)\n  perm.mode.reorder<-reorderCCA(perm.mode,org.mode)\n}\n\nccaDWpermrank <- function(X,Y,pen_x,pen_y,rank){\n  perm.mode<-PMA::CCA(x=X, z=Y, typex=c(\"standard\"),typez=c(\"standard\"), penaltyx=pen_x, penaltyz=pen_y, K=rank, niter=20, trace=FALSE)\n  cor.order <- order(-perm.mode$cors)\n  perm.mode$cors <- perm.mode$cors[cor.order]\n  perm.mode$u <- perm.mode$u[,cor.order]\n  perm.mode$v <- perm.mode$v[,cor.order]\n  perm.mode\n}\n\nccaDWcv <- function(X,Y,pen_x,pen_y,rank,foldid) {  \n  # run cca on the training set\n  cca_train <- mclapply(foldid, function(id)  ccaDW( X[id,] , Y[id,] , pen_x , pen_y , rank))\n  \n  # apply the loadings onto testing data and calculate the CV score on each fold\n  cv_results <- mclapply(seq_along(foldid), function(i) cv_score(cca_train[[i]]$u, cca_train[[i]]$v, X[ -foldid[[i]] , ] , Y[ -foldid[[i]] , ]))\n  \n  # take the mean CV\n  cv_mean <- mean(unlist(cv_results))\n  cv_sd <- sd(unlist(cv_results))\n  cv_all <- unlist(cv_results)\n  \n  # take ave of the correlation estimated\n  fold_cor <- mclapply(seq_along(foldid), function(i) cca_train[[i]]$cors)\n  cor_mean <- mean(unlist(fold_cor))\n  \n  \n  # output\n  out<-list(CV_SCORE=cv_mean,CV_SD = cv_sd, CV_ALL = cv_all, COR_MEAN=cor_mean, PEN_X = pen_x, PEN_Y = pen_y,RANK=rank)\n}\n\nccaDWgs <-function(X,Y,pen_xseq,pen_yseq, rank, foldid){\n  #loop through x penalty sequence\n  gs_x<-function(X,Y,pen_xseq,pen_yseq, rank,foldid){\n    gs_x <- mclapply(pen_xseq,function(x) ccaDWcv(X,Y,x,pen_yseq,rank,foldid))\n  }\n  #loop through y penalty sequence\n  gs_y <- mclapply(pen_yseq,function(y) gs_x(X,Y,pen_xseq, y,rank,foldid))\n  \n  #summarize the result\n  gs2 <- unlist(gs_y,recursive = F)\n  gs.out <- t(sapply(gs2, function(x) unlist(x)))\n  \n  #find the parameters with the best CV score\n  cv.max <- max(gs.out[,'CV_SCORE'])\n  cv.max.loc <- which.max(gs.out[,'CV_SCORE'])\n  \n  best.para = gs.out[cv.max.loc,]\n  final.cca <- ccaDW(X,Y,as.numeric(best.para['PEN_X']),as.numeric(best.para['PEN_Y']),rank)\n  out <- list(GRIDSEARCH=gs.out, BEST_PARA=best.para , FINAL_CCA = final.cca)\n}\n\n# permutation test in the test data\nccaDWpm <- function(Xtest,Ytest,uhat,vhat,nperm){\n  Xtest.perm <- rlply(nperm,Xtest[sample(nrow(Xtest)),])\n  \n  Xtest.perm.cor <- mclapply(Xtest.perm, function(xperm) cv_score(uhat, vhat, xperm, Ytest) )\n  \n  Xtest.real.cor <- cv_score(uhat,vhat,Xtest,Ytest)\n  \n  p.val <- length(which(abs(unlist(Xtest.perm.cor)) >= abs(as.numeric(unlist(Xtest.real.cor)))))/nperm\n  out <- list(PERMCOR = Xtest.perm.cor, REALCOR = Xtest.real.cor  , PVAL = p.val )\n}\n\n# permutation test within the training data\nccaDWpermtr <- function(Xtrain,Ytrain,nperm,x_pen,y_pen,rank){\n  real.cor <- ccaDW(Xtrain,Ytrain,x_pen,y_pen,rank)\n  \n  Xtrain.perm <- rlply(nperm,Xtrain[sample(nrow(Xtrain)),])\n  Xtrain.perm <- mclapply(Xtrain.perm, function(xperm) ccaDW(xperm,Ytrain,x_pen,y_pen,rank))\n  \n  perm.cor <- sapply(seq_along(Xtrain.perm), function(i) Xtrain.perm[[i]]$cors)\n  p.val <- length(which(perm.cor >= real.cor$cors))/nperm\n  out <- list(REALCOR = real.cor$cors, PVAL = p.val, PEN_X = x_pen, PEN_Y = y_pen)\n}\n\nccaDWpermgs <-function(X,Y,pen_xseq,pen_yseq,rank, nperm){\n  #loop through x penalty sequence\n  gs_x<-function(X,Y,pen_xseq,pen_yseq, rank,nperm){\n    gs_x <- mclapply(pen_xseq,function(x) ccaDWpermtr(X,Y,nperm,x,pen_yseq,rank))\n  }\n  #loop through y penalty sequence\n  gs_y <- mclapply(pen_yseq,function(y) gs_x(X,Y,pen_xseq, y,rank,nperm))\n  \n  #summarize the result\n  gs2 <- unlist(gs_y,recursive = F)\n  gs.out <- t(sapply(gs2, function(x) unlist(x)))\n  \n  #find the parameters with the smallest perm p-val\n  p.min <- min(gs.out[,'PVAL'])\n  \n  p.min.loc <- which.min(gs.out[,'PVAL'])\n  \n  best.para = gs.out[p.min.loc,]\n  final.cca <- ccaDW(X,Y,as.numeric(best.para['PEN_X']),as.numeric(best.para['PEN_Y']),rank)\n  out <- list(GRIDSEARCH=gs.out, BEST_PARA=best.para , FINAL_CCA = final.cca)\n}\n\nccaDWfoldgs <-function(Xlist,Ylist,pen_xseq,pen_yseq){\n  #loop through x penalty sequence\n  gs_x<-function(X,Y,pen_xseq,pen_yseq){\n    gs_x <- mclapply(pen_xseq,function(pen_x) ccaDWfold(X,Y,pen_x,pen_yseq))\n  }\n  #loop through y penalty sequence\n  gs_y <- mclapply(pen_yseq,function(pen_y) gs_x(Xlist,Ylist,pen_xseq,pen_y))\n  \n  #summarize the result\n  gs2 <- unlist(gs_y,recursive = F)\n  gs.out <- t(sapply(gs2, function(x) unlist(x)))\n  \n  #find the parameters with the largest correlations\n  best.para <- gs.out[which.max(gs.out[,'COR_MEAN']),]\n  best.cor <- as.numeric(best.para[1])\n  best.penx <- as.numeric(best.para[2])\n  best.peny <- as.numeric(best.para[3])\n  out <-list(GS = gs.out,COR= best.cor, PENX = best.penx, PENY = best.peny)\n}\n\nccaDWfold <- function(Xlist,Ylist,pen_x,pen_y){\n  result.cca<-mclapply(seq_along(Xlist),function(i) ccaDW(Xlist[[i]],Ylist[[i]],pen_x,pen_y,1))\n  result.cor <- sapply(seq_along(Xlist), function(i) result.cca[[i]]$cors)\n  result.cor.mean <- mean(result.cor)\n  out <-list(COR_MEAN = result.cor.mean, PEN_X= pen_x, PEN_Y = pen_y)\n}\n\nreorderCCA <- function(res,org,k){\n  u <- org$u\n  v <- org$v\n  \n  res.match<-apply(abs(cor(v,res$v[,1:k])),1,which.max)\n  res.cor <- apply(abs(cor(v,res$v[,1:k])),1,max)\n  res.match.count <- length(unique(res.match))\n  \n  u.od <- res$u[,res.match]\n  v.od <- res$v[,res.match]\n  cors.final <- res$cors[res.match]\n  \n  org.sign <- sign(colMeans(sign(v)))\n  res.sign <- sign(colMeans(sign(v.od)))\n  \n  sign.prod <- org.sign *res.sign\n  \n  u.final <- t(t(u.od) * sign.prod)\n  v.final <- t(t(v.od) * sign.prod)\n  \n  res.one.reorder <- list(u= u.final ,v= v.final, cors = cors.final, pos = res.match, dimcor = res.cor)\n  \n  if (res.match.count < dim(u)[2]  ) {\n    u.na <- array(NA,dim= c(dim(u)[1],dim(u)[2]))\n    v.na <- array(NA,dim= c(dim(v)[1],dim(v)[2]))\n    cors.na <- rep(NA,dim(u)[2])\n    match.na <- cors.na\n    dimcor.na <- cors.na\n    res.one.reorder <- list(u= u.na,v= v.na, cors = cors.na, pos = res.match, dimcor = dimcor.na) \n  }\n  out <- res.one.reorder\n}\n\nbootstats <- function(bootdata){\n  boot.stats <- data.frame(mean = rowMeans(bootdata,na.rm = T), se= rowSds(bootdata,na.rm = T) )\n  boot.stats$me = boot.stats$se * qt(.95, df=dim(bootdata)[2]-1) \n  boot.stats$up <- boot.stats$mean + boot.stats$me\n  boot.stats$lw <- boot.stats$mean - boot.stats$me\n  boot.stats\n}\n\nbootstats2 <- function(org,bootdata){\n  boot.stats <- sapply(seq_along(1:length(org)), function(i) org[i] - quantile(bootdata[i,] - org[i],c(0.975,0.025),na.rm =T))\n  boot.stats <- as.data.frame(t(boot.stats))\n  colnames(boot.stats)<-c(\"low\",\"high\")\n  boot.stats$ci <- boot.stats$high - boot.stats$low\n  boot.stats$load <- org\n  boot.stats$fea <- 1:length(org)\n  boot.stats\n  }\n\nbootplot <- function(org, boot){\n  btst <- bootstats2(org,boot)\n\n  p <- ggplot(btst,aes(fea,load))+\n    geom_point(aes(colour = low * high > 0)) +\n    geom_errorbar(aes(ymax = high, ymin = low),  width=0.25) +\n    theme_classic()\n  \n  fea <- which(btst$low * btst$high >0)\n  load <- org[fea]\n  fea <- fea[order(-abs(load))]\n  load <- load[order(-abs(load))]\n  out <- list(plot = p, fea = fea, load = load)\n}\n\n## write an alternative bootplot function for the u's so it doesn't involve the absolute values\n\nbootplot_u <- function(org, boot){\n  btst <- bootstats2(org,boot)\n  \n  p <- ggplot(btst,aes(fea,load))+\n    geom_point(aes(colour = low * high > 0)) +\n    geom_errorbar(aes(ymax = high, ymin = low),  width=0.25) +\n    theme_classic()\n  \n  fea <- which(btst$low * btst$high >0)\n  load <- org[fea]\n  #fea <- fea[order(-abs(load))]\n  #load <- load[order(-abs(load))]\n  load_nm <- org / btst$ci\n  load_nm_fea <- load_nm[fea]\n  out <- list(plot = p, fea = fea, load = load, load_nm = load_nm, load_nm_fea = load_nm_fea)\n}\n\n\n\n\nmed_vis <- function(mddim,title){\n  mddim$feaitem <- item$Question[mddim$fea]\n  mddim$code <- item$clinicalcode[mddim$fea]\n  mddim$cate <- gsub(\"[[:digit:]]\",\"\",mddim$code)\n  mddim.vis <- as.data.frame(within(mddim,rm(\"plot\")))\n  ggplot(mddim.vis,aes(rep(1,length(mddim$load)),abs(load))) +\n    geom_point(aes(size= abs(load*10),alpha =abs(load) )) +\n    scale_alpha(guide = 'none') +\n    scale_size(guide = \"none\") +\n    coord_cartesian(xlim = c(1, 20)) +\n    geom_label_repel(data = mddim.vis,aes(fill = factor(cate), label = feaitem), \n                     colour = \"white\", force = 3, nudge_x=10) +\n    theme(axis.ticks = element_blank(), axis.text.x = element_blank()) +\n    theme(legend.position=\"top\") +\n    scale_fill_discrete(name=\"\") +\n    labs(title = title ,x='',y= \"CCA Loadings\") \n}\n\nbrain_vis <- function(braindim,title,sign,idx, parcels){\n  ccamat <- array(0,c(264,264)) #create a blank matrix\n  ccamat.up<-ccamat[upper.tri(ccamat,diag=F)] \n  \n  ccamat.up[idx[braindim$fea]] <- braindim$load_nm_fea\n  #ccamat.up[idx] <- braindim$load_nm\n  \n  ccamat[upper.tri(ccamat,diag=F)]  <- ccamat.up\n  ccamat <- sna::symmetrize(ccamat,rule = 'upper')\n  ccamat <- sign * ccamat\n  ccamat <- ccamat[parcels$ROI,parcels$ROI]\n  ccamat.lim <- max(abs(ccamat),na.rm=T)\n  p <- levelplot(ccamat,par.settings = BuRdTheme(), at = seq(-ccamat.lim,ccamat.lim,length.out = 100), main=title)\n  \n  our <- list(plot = p, mat = ccamat)\n}\n\nload_by_ft_plot <- function(load_mat,ave_mat){\n  #emp_mat <- array(0, c(264,264))\n  #ave_ft<-colMeans(pwr_train_net_ft,na.rm = T)\n  #emp_mat[upper.tri(emp_mat,diag = F)] <- ave_ft\n  #ave_ft_mat <- sna::symmetrize(emp_mat,rule = \"upper\") \n  #ave_ft_mat <- ave_ft_mat[parcelsTR$ROI,parcelsTR$ROI]\n  \n  #ave_ft_lim <- max(abs(ave_ft_mat),na.rm=T)\n  #levelplot(ave_ft_mat,par.settings = BuRdTheme(), at = seq(-ave_ft_lim,ave_ft_lim,length.out = 100))\n  \n  loadbyft <- sign(ave_mat) * load_mat\n  loadbyft_lim <- max(abs(loadbyft),na.rm=T)\n  \n  p <- levelplot(loadbyft,par.settings = BuRdTheme(), at = seq(-loadbyft_lim,loadbyft_lim,length.out = 100))\n  \n  out <- list(plot = p, mat = loadbyft)\n}\n\n\n\n\nmod_calc_within <- function (bi_brain_mat, mod_assign){\n within<-sapply(1:length(unique(mod_assign)),function(x) mean(bi_brain_mat[mod_assign == unique(mod_assign)[x],mod_assign == unique(mod_assign)[x]]))\n \n}\n\n\nmod_pair<-function(bi_brain_mat, mod_assign, seed){\n  \n  seed_mod <- unique(mod_assign)[seed]\n  pair_seq <- (1+seed):length(unique(mod_assign))\n  sapply(pair_seq, function(x) mean(bi_brain_mat[mod_assign == seed_mod, mod_assign == unique(mod_assign)[x] ], na.rm = T))\n}\n\nmod_calc_between <- function (bi_brain_mat, mod_assign){\nbetween<-sapply(1:(length(unique(mod_assign))-1),function(x) mod_pair(bi_brain_mat,mod_assign,x))\nbetween <- unlist(between)\n}\n\nmod_pair_name<-function(mod_name, seed){\n  seed_mod <- unique(mod_name)[seed]\n  pair_seq <- (1+seed):length(mod_name)\n  sapply(pair_seq, function(x) paste(seed_mod,'-',mod_name[x]))\n}\n\nmod_calc_between_name <- function (mod_name){\n  between<-sapply(1:(length(mod_name)-1),function(x) mod_pair_name(mod_name,x))\n  between <- unlist(between)\n}\n\nmod_rich_within<-function(brbft) {\n  #binarize the brain by ft matrix\n  brbft[is.na(brbft)] <-0\n  brbft[which(brbft != 0)] <- 1\n  \n  \n  #permute the membership of modules\n  nperm = 1000\n  mod_mem_perm <- rlply(nperm,sample(parcelsTR$Community))\n  \n  #calculate mod enrichment\n  modrich <- mod_calc_within(brbft,parcelsTR$Community)\n  \n  #calc perm mod enrich\n  mod_perm<-sapply(mod_mem_perm,function(x) mod_calc_within(brbft, x))\n  \n  #calc p val\n  mod_pval <- sapply(1:dim(mod_perm)[1], function(x) length(which(mod_perm[x,]>=modrich[x])) / nperm )\n  sig_mod_idx <- which(mod_pval < 0.05)\n  sig_mod <-unique(parcelsTR$System)[sig_mod_idx]\n  sig_mod_idx <- unique(parcelsTR$Community)[sig_mod_idx]\n  \n  out <- list(RICH = modrich, PVAL = mod_pval, MOD = sig_mod, MODid = sig_mod_idx)\n}\n\nmod_rich_between<-function(brbft) {\n  #calc between mod mean loading\n  modmean <- mod_calc_between(brbft,parcelsTR$Community)\n  \n  #binarize the brain by ft matrix\n  brbft[is.na(brbft)] <-0\n  brbft[which(brbft != 0)] <- 1\n  \n  \n  #permute the membership of modules\n  nperm = 1000\n  mod_mem_perm <- rlply(nperm,sample(parcelsTR$Community))\n  \n  #calculate mod enrichment\n  modrich <- mod_calc_between(brbft,parcelsTR$Community)\n  \n  #calc perm mod enrich\n  mod_perm<-sapply(mod_mem_perm,function(x) mod_calc_between(brbft, x))\n  \n  #calc p val\n  mod_pval <- sapply(1:dim(mod_perm)[1], function(x) length(which(mod_perm[x,]>=modrich[x])) / nperm )\n  mod_pval_fdr <- p.adjust(mod_pval,method = \"fdr\")\n\n  sig_mod_idx <- which(mod_pval_fdr <0.05)\n  sig_mod <-between_name[sig_mod_idx]\n\n  out <- list(MEAN = modmean, RICH = modrich, PVAL = mod_pval,PVAL_fdr = mod_pval_fdr, MOD = sig_mod, MODid = sig_mod_idx)\n}\n\n\nwithin_mod_plot <- function(netmat,mod){\n  brainmat <- netmat\n  brainlim = max(abs(brainmat),na.rm = T)\n  mod <- unique(parcelsTR$Community)[mod]\n  title <- toString(unique(parcelsTR$System[which(parcelsTR$Community==mod)]))\n  levelplot(brainmat[parcelsTR$Community==mod,parcelsTR$Community==mod],par.settings = BuRdTheme(), at = seq(-brainlim,brainlim,length.out=100), xlab=\"\", ylab=\"\",main = title )\n}\n\nwithin_mod_calc <- function(netmat,mod){\n  title <- modname[mod]\n  brainmat <- netmat\n  brainlim = max(abs(brainmat),na.rm = T)\n  mod <- unique(parcelsTR$Community)[mod]\n  list(mod = title, mean = mean(brainmat[parcelsTR$Community==mod,parcelsTR$Community==mod],na.rm=T))\n}\n\nlistplot<-function(list_of_plot,subname) {\n  for (i in seq_along(list_of_plot)) {\n    plotname <- paste('./projects/xiaNetworkCca/sCCA/aim1/figure/201701/',subname,'_',i,'.pdf',sep=\"\")\n    pdf(file = plotname)\n    print(list_of_plot[[i]])\n    dev.off()\n  }\n}\n\n\nbetween_mod_plot<-function(betweenmod,withinmod, title) {\n  modname <- c(\"UNK\",\"Hand\",\"Mouth\",\"Cgl-Op\",\"Aud\",\"DMN\",\"Mmy\",\"Vis\",\"FrtPrt\",\"Sln\",\"SbC\",\"VTN\",\"DTN\",\"CRB\")\n  mod_mat <- array(0,c(14,14))\n  mod_mat[lower.tri(mod_mat,diag = F)][betweenmod$MODid] <- 1\n  withinmod_id<-rapply(withinmod[1,], function(x) which(modname == x))\n  diag(mod_mat)[withinmod_id] <- 1\n  mod_mat <- sna::symmetrize(mod_mat,rule = \"lower\")\n  colnames(mod_mat) <- modname\n  rownames(mod_mat) <- modname\n  p<-levelplot(mod_mat, par.settings = BuRdTheme(), at = seq(-1,1,length.out = 10), xlab=\"\",ylab = \"\",scales=list(x=list(rot=90)),colorkey = FALSE, main = title)\n  print(p)\n}\n\nbetween_mod_load_plot<-function(betweenmod,withinmod,title) {\n  modname <- c(\"UNK\",\"Hand\",\"Mouth\",\"Cgl-Op\",\"Aud\",\"DMN\",\"Mmy\",\"Vis\",\"FrtPrt\",\"Sln\",\"SbC\",\"VTN\",\"DTN\",\"CRB\")\n  mod_mat <- array(0,c(14,14))\n  mod_mat[lower.tri(mod_mat,diag = F)][betweenmod$MODid] <- betweenmod$MEAN[betweenmod$MODid]\n  withinmod_id<-rapply(withinmod[1,], function(x) which(modname == x))\n  diag(mod_mat)[withinmod_id] <- simplify2array(withinmod[2,])\n  mod_mat <- sna::symmetrize(mod_mat,rule = \"lower\")\n  colnames(mod_mat) <- modname\n  rownames(mod_mat) <- modname\n  modlim <- max(abs(mod_mat),na.rm = T)\n  #modlim <- 0.08\n  p<-levelplot(mod_mat, par.settings = BuRdTheme(), at = seq(-modlim,modlim,length.out = 100), xlab=\"\",ylab = \"\",scales=list(x=list(rot=90)), main = title)\n  out <- list(MAT = mod_mat, plot = p)\n}\n\nbt_mod_diff <- function(dim1, dim2, title){\n  dimdiff <- dim1$MAT - dim2$MAT\n  difflim <- max(abs(dimdiff),na.rm = T)\n  p<-levelplot(dimdiff, par.settings = BuRdTheme(), at = seq(-difflim,difflim,length.out = 100), xlab=\"\",ylab = \"\",scales=list(x=list(rot=90)), main = title)\n  print(p)\n}\n\nmask_mat<-function(sample_net_ft_rg) {\n  sample_net_ave <- colMeans(sample_net_ft_rg)\n  ave_mat <- array(0,c(264,264))\n  ave_mat[upper.tri(ave_mat,diag=F)][pwr.3k.train.idx] <- sample_net_ave\n  ave_mat <- sna::symmetrize(ave_mat,rule = \"upper\")\n  ave_mat <- ave_mat[parcelsTR$ROI,parcelsTR$ROI]\n  mat_lim <- max(abs(ave_mat))\n  p<-levelplot(ave_mat, par.settings = BuRdTheme(),at = seq(-mat_lim,mat_lim,length.out = 100))\n  out <- list(ave_mat = ave_mat, plot = p)\n}",
    "created" : 1486699379665.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1491298780",
    "id" : "38CE46E7",
    "lastKnownWriteTime" : 1486156413,
    "last_content_update" : 1486156413,
    "path" : "~/Desktop/BBL/projects/xiaNetworkCca/sCCA/code/cca_functions.R",
    "project_path" : "cca_functions.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}